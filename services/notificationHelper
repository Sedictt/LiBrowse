// services/notificationHelper.js
// Helper to create both in-app and email notifications

const { getConnection } = require('../config/database');
const EmailService = require('./emailService');

class NotificationHelper {
    /**
     * Send borrow request notification
     */
    static async notifyBorrowRequest(lenderId, borrowerName, bookTitle, bookAuthor, message, actionUrl, relatedId = null) {
        const connection = await getConnection();

        // Get lender email
        const [lender] = await connection.execute(
            'SELECT email FROM users WHERE id = ?',
            [lenderId]
        );

        // Create in-app notification (schema-aligned)
        await connection.execute(`
            INSERT INTO notifications 
            (user_id, title, body, category, related_id, is_read)
            VALUES (?, ?, ?, ?, ?, FALSE)
        `, [
            lenderId,
            `New Borrow Request from ${borrowerName}`,
            JSON.stringify({ borrowerName, bookTitle, message }),
            'transaction',
            relatedId || 0
        ]);

        // Send email
        if (lender && lender[0].email) {
            await EmailService.sendNotificationEmail(
                lender[0].email,
                `üìö New Borrow Request for "${bookTitle}"`,
                'request',
                {
                    lenderName: lender[0].fname,
                    borrowerName,
                    bookTitle,
                    bookAuthor,
                    message,
                    duration: '2 weeks',
                    actionUrl: actionUrl || 'https://librowse.app/transactions'
                }
            );
        }

        connection.release();
    }

    /**
     * Send approval notification
     */
    static async notifyApproval(borrowerId, lenderName, bookTitle, bookAuthor, returnDate, actionUrl, relatedId = null) {
        const connection = await getConnection();

        // Get borrower email
        const [borrower] = await connection.execute(
            'SELECT email FROM users WHERE id = ?',
            [borrowerId]
        );

        // Create in-app notification (schema-aligned)
        await connection.execute(`
            INSERT INTO notifications 
            (user_id, title, body, category, related_id, is_read)
            VALUES (?, ?, ?, ?, ?, FALSE)
        `, [
            borrowerId,
            `Request Approved by ${lenderName}`,
            JSON.stringify({ lenderName, bookTitle, returnDate }),
            'transaction',
            relatedId || 0
        ]);

        // Send email
        if (borrower && borrower[0].email) {
            await EmailService.sendNotificationEmail(
                borrower[0].email,
                `‚úì Borrow Request Approved for "${bookTitle}"`,
                'approval',
                {
                    borrowerName: borrower[0].fname,
                    lenderName,
                    bookTitle,
                    bookAuthor,
                    returnDate,
                    actionUrl: actionUrl || 'https://librowse.app/transactions'
                }
            );
        }

        connection.release();
    }

    /**
     * Send return reminder (1 day before due date)
     */
    static async notifyReturnReminder(borrowerId, bookTitle, bookAuthor, returnDate, actionUrl, relatedId = null) {
        const connection = await getConnection();

        // Get borrower email
        const [borrower] = await connection.execute(
            'SELECT email FROM users WHERE id = ?',
            [borrowerId]
        );

        // Create in-app notification (schema-aligned)
        await connection.execute(`
            INSERT INTO notifications 
            (user_id, title, body, category, related_id, is_read)
            VALUES (?, ?, ?, ?, ?, FALSE)
        `, [
            borrowerId,
            `Reminder: Return "${bookTitle}"`,
            JSON.stringify({ bookTitle, returnDate, kind: 'due_soon' }),
            'reminder',
            relatedId || 0
        ]);

        // Send email
        if (borrower && borrower[0].email) {
            await EmailService.sendNotificationEmail(
                borrower[0].email,
                `üìÖ Reminder: Return "${bookTitle}" Soon`,
                'reminder',
                {
                    borrowerName: borrower[0].fname,
                    bookTitle,
                    bookAuthor,
                    returnDate,
                    actionUrl: actionUrl || 'https://librowse.app/transactions'
                }
            );
        }

        connection.release();
    }

    /**
     * Send overdue alert
     */
    static async notifyOverdue(borrowerId, bookTitle, bookAuthor, dueDate, daysOverdue, actionUrl, relatedId = null) {
        const connection = await getConnection();

        // Get borrower email
        const [borrower] = await connection.execute(
            'SELECT email FROM users WHERE id = ?',
            [borrowerId]
        );

        // Create in-app notification (schema-aligned)
        await connection.execute(`
            INSERT INTO notifications 
            (user_id, title, body, category, related_id, is_read)
            VALUES (?, ?, ?, ?, ?, FALSE)
        `, [
            borrowerId,
            `Overdue: Return "${bookTitle}"`,
            JSON.stringify({ bookTitle, dueDate, daysOverdue, kind: 'overdue' }),
            'reminder',
            relatedId || 0
        ]);

        // Send email
        if (borrower && borrower[0].email) {
            await EmailService.sendNotificationEmail(
                borrower[0].email,
                `‚ö†Ô∏è OVERDUE: "${bookTitle}" Must Be Returned Now`,
                'overdue',
                {
                    borrowerName: borrower[0].fname,
                    bookTitle,
                    bookAuthor,
                    dueDate,
                    daysOverdue,
                    actionUrl: actionUrl || 'https://librowse.app/transactions'
                }
            );
        }

        connection.release();
    }

    /**
     * Notify user about verification completion (OCR ID verification)
     */
    static async notifyVerificationResult(userId, { verificationId, autoApproved, verificationStatus, failureReasons }) {
        const connection = await getConnection();

        const title = autoApproved
            ? 'ID Verification Successful'
            : 'ID Verification Pending Review';

        const body = {
            message: autoApproved
                ? 'Your student ID was verified successfully. Your account is now verified.'
                : (Array.isArray(failureReasons) && failureReasons.length
                    ? `Verification pending: ${failureReasons.join(' ')}`
                    : 'Your documents were processed. Admin review is in progress.'),
            status: verificationStatus,
            autoApproved: !!autoApproved,
            failureReasons: failureReasons || []
        };

        await connection.execute(`
            INSERT INTO notifications
            (user_id, title, body, category, related_id, is_read)
            VALUES (?, ?, ?, 'system', ?, FALSE)
        `, [
            userId,
            title,
            JSON.stringify(body),
            verificationId || 0
        ]);

        connection.release();
    }

    /**
     * Notify user about verification failure (when OCR job itself fails)
     */
    static async notifyVerificationFailure(userId, errorMessage) {
        const connection = await getConnection();

        const body = {
            message: 'We could not process your documents. Please upload clearer photos and try again.',
            error: errorMessage || null
        };

        await connection.execute(`
            INSERT INTO notifications
            (user_id, title, body, category, related_id, is_read)
            VALUES (?, 'ID Verification Failed', ?, 'system', NULL, FALSE)
        `, [
            userId,
            JSON.stringify(body)
        ]);

        connection.release();
    }
}

module.exports = NotificationHelper;
