// services/notificationHelper.js
// Helper to create both in-app and email notifications

const { getConnection } = require('../config/database');
const EmailService = require('./emailService');

class NotificationHelper {
    /**
     * Send borrow request notification
     */
    static async notifyBorrowRequest(lenderId, borrowerName, bookTitle, bookAuthor, message, actionUrl, relatedId = null) {
        const connection = await getConnection();

        // Get lender email
        const [lender] = await connection.execute(
            'SELECT email FROM users WHERE id = ?',
            [lenderId]
        );

        // Create in-app notification (schema-aligned)
        await connection.execute(`
            INSERT INTO notifications 
            (user_id, title, body, category, related_id, is_read)
            VALUES (?, ?, ?, ?, ?, FALSE)
        `, [
            lenderId,
            `New Borrow Request from ${borrowerName}`,
            JSON.stringify({ borrowerName, bookTitle, message }),
            'transaction',
            relatedId || 0
        ]);

        // Send email
        if (lender && lender[0].email) {
            await EmailService.sendNotificationEmail(
                lender[0].email,
                `üìö New Borrow Request for "${bookTitle}"`,
                'request',
                {
                    lenderName: lender[0].fname,
                    borrowerName,
                    bookTitle,
                    bookAuthor,
                    message,
                    duration: '2 weeks',
                    actionUrl: actionUrl || 'https://librowse.app/transactions'
                }
            );
        }

        connection.release();
    }

    /**
     * Send approval notification
     */
    static async notifyApproval(borrowerId, lenderName, bookTitle, bookAuthor, returnDate, actionUrl, relatedId = null) {
        const connection = await getConnection();

        // Get borrower email
        const [borrower] = await connection.execute(
            'SELECT email FROM users WHERE id = ?',
            [borrowerId]
        );

        // Create in-app notification (schema-aligned)
        await connection.execute(`
            INSERT INTO notifications 
            (user_id, title, body, category, related_id, is_read)
            VALUES (?, ?, ?, ?, ?, FALSE)
        `, [
            borrowerId,
            `Request Approved by ${lenderName}`,
            JSON.stringify({ lenderName, bookTitle, returnDate }),
            'transaction',
            relatedId || 0
        ]);

        // Send email
        if (borrower && borrower[0].email) {
            await EmailService.sendNotificationEmail(
                borrower[0].email,
                `‚úì Borrow Request Approved for "${bookTitle}"`,
                'approval',
                {
                    borrowerName: borrower[0].fname,
                    lenderName,
                    bookTitle,
                    bookAuthor,
                    returnDate,
                    actionUrl: actionUrl || 'https://librowse.app/transactions'
                }
            );
        }

        connection.release();
    }

    /**
     * Send return reminder (1 day before due date)
     */
    static async notifyReturnReminder(borrowerId, bookTitle, bookAuthor, returnDate, actionUrl, relatedId = null) {
        const connection = await getConnection();

        // Get borrower email
        const [borrower] = await connection.execute(
            'SELECT email FROM users WHERE id = ?',
            [borrowerId]
        );

        // Create in-app notification (schema-aligned)
        await connection.execute(`
            INSERT INTO notifications 
            (user_id, title, body, category, related_id, is_read)
            VALUES (?, ?, ?, ?, ?, FALSE)
        `, [
            borrowerId,
            `Reminder: Return "${bookTitle}"`,
            JSON.stringify({ bookTitle, returnDate, kind: 'due_soon' }),
            'reminder',
            relatedId || 0
        ]);

        // Send email
        if (borrower && borrower[0].email) {
            await EmailService.sendNotificationEmail(
                borrower[0].email,
                `üìÖ Reminder: Return "${bookTitle}" Soon`,
                'reminder',
                {
                    borrowerName: borrower[0].fname,
                    bookTitle,
                    bookAuthor,
                    returnDate,
                    actionUrl: actionUrl || 'https://librowse.app/transactions'
                }
            );
        }

        connection.release();
    }

    /**
     * Send overdue alert
     */
    static async notifyOverdue(borrowerId, bookTitle, bookAuthor, dueDate, daysOverdue, actionUrl, relatedId = null) {
        const connection = await getConnection();

        // Get borrower email
        const [borrower] = await connection.execute(
            'SELECT email FROM users WHERE id = ?',
            [borrowerId]
        );

        // Create in-app notification (schema-aligned)
        await connection.execute(`
            INSERT INTO notifications 
            (user_id, title, body, category, related_id, is_read)
            VALUES (?, ?, ?, ?, ?, FALSE)
        `, [
            borrowerId,
            `Overdue: Return "${bookTitle}"`,
            JSON.stringify({ bookTitle, dueDate, daysOverdue, kind: 'overdue' }),
            'reminder',
            relatedId || 0
        ]);

        // Send email
        if (borrower && borrower[0].email) {
            await EmailService.sendNotificationEmail(
                borrower[0].email,
                `‚ö†Ô∏è OVERDUE: "${bookTitle}" Must Be Returned Now`,
                'overdue',
                {
                    borrowerName: borrower[0].fname,
                    bookTitle,
                    bookAuthor,
                    dueDate,
                    daysOverdue,
                    actionUrl: actionUrl || 'https://librowse.app/transactions'
                }
            );
        }

        connection.release();
    }
}

module.exports = NotificationHelper;
